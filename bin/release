#!/bin/bash

set -e -u -o pipefail
# set -x

declare -r WD="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd -P)"

info() {
    printf "\x1b[32m\xE2\x87\x92 %s\x1b[0m\n" "$1"
}

error() {
    printf "\x1b[97m\x1b[41m\x21\x1b[0m \x1b[31m%s\x1b[0m\n" "$1" 1>&2
    exit 1
}

get_version() {
    grep -E '^version' Cargo.toml | grep -Eo '([\.0-9]+)'
}

get_branch() {
    git branch | grep -E "^\*" | awk '{print $2}'
}

get_access_token() {
    local file=$1
    cat "$file"
}

get_payload() {
    local version=$1
    cat <<EOM
{
  "tag_name": "v$version",
  "target_commitish": "master",
  "name": "v$version",
  "body": "Release of version $version",
  "draft": false,
  "prerelease": false
}
EOM
}

get_confirmation_message() {
    local branch=$1
    local version=$2

  cat <<EOM
You are about to create a new release:
- Branch: \x1b[33m${branch}\x1b[0m
- Version: \x1b[33m${version}\x1b[0m

Do you want to proceed [y/N]:
EOM
}

get_next_branch_message() {
    local major=$1
    local minor=$2
    local patch=$3

    cat <<EOM
Do you want to create the next release branch? [No]:
1) Major Version (\x1b[33m$major\x1b[0m)
2) Minor Version (\x1b[33m$minor\x1b[0m)
3) Patch Version (\x1b[33m$patch\x1b[0m)
>
EOM
}

split_version() {
    local numbers=(${1//./ })
    echo "${numbers[@]}"
}

get_next_major_version() {
    local numbers=($(split_version "$1"))
    [[ ${#numbers[@]} -eq 3 ]] && echo "$((numbers[0] + 1)).${numbers[1]}.${numbers[2]}"
}

get_next_minor_version() {
    local numbers=($(split_version "$1"))
    [[ ${#numbers[@]} -eq 3 ]] && echo "${numbers[0]}.$((numbers[1] + 1)).${numbers[2]}"
}

get_next_patch_version() {
    local numbers=($(split_version "$1"))
    [[ ${#numbers[@]} -eq 3 ]] && echo "${numbers[0]}.${numbers[1]}.$((numbers[2] + 1))"
}

create_next_release_branch() {
    local version=$1
    local major=$(get_next_major_version "$version")
    local minor=$(get_next_minor_version "$version")
    local patch=$(get_next_patch_version "$version")

    read -erp "$(echo -e "$(get_next_branch_message "$major" "$minor" "$patch")") " next_branch

    local branch_name=
    case $next_branch in
        1) branch_name="$major";;
        2) branch_name="$minor";;
        3) branch_name="$patch";;
    esac

    if [[ -n "$branch_name" ]]; then

        read -erp "$(echo -e "Do you want to create the branch with the name '\x1b[33m${branch_name}\x1b[0m'") [Y/n] " confirm

        [[ -z "$confirm" ]] && confirm="y"

        if [[ "$confirm" == y ]]; then
            git checkout -b "$branch_name"
            git push
        fi
    else
        info "Skipped!"
    fi
}

main() {
    local owner="mickaelvieira"
    local repo="vagment"
    local endpoint="https://api.github.com/repos/$owner/$repo/releases"
    local branch="$(get_branch)"
    local version="$(get_version)"
    local credentials="$WD/github/.access_token"

    [[ "$branch" != master ]] && error "Your are not on the master branch mate."
    [[ -f "$credentials" ]] || error "Access Token file does not exist"

    local token=$(get_access_token "$credentials")
    local payload=$(get_payload "$version")
    local message=$(get_confirmation_message "$branch" "$version")

    read -erp "$(echo -e "$message")" answer

    [[ -z "$answer" ]] && answer="n"

    if [[ "$answer" == y ]]; then
        info "Calling Github API..."
        curl -v \
          -X POST \
          -H "Content-Type: application/json" \
          -H "Authorization: token $token" \
          --data "$payload" \
          "$endpoint"

        create_next_release_branch "$version"
    else
        info "skipped!"
    fi
}

main
